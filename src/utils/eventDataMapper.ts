// src/utils/eventDataMapper.ts
import { Timestamp, DocumentData, deleteField, serverTimestamp } from 'firebase/firestore';
import {
    Event,
    EventFormData,
    EventCriteria,
    EventLifecycleTimestamps
} from '@/types/event';
import { DateTime } from 'luxon';

// Helper function to convert JS Date or ISO string to Firestore Timestamp in IST
export const getISTTimestamp = (dateInput: Date | string | Timestamp | { seconds: number, nanoseconds: number } | null | undefined): Timestamp | null => {
    if (!dateInput) return null;
    if (dateInput instanceof Timestamp) return dateInput;

    if (typeof dateInput === 'object' && 'seconds' in dateInput && 'nanoseconds' in dateInput && !(dateInput instanceof Date)) {
        return new Timestamp(dateInput.seconds, dateInput.nanoseconds);
    }

    let dt: DateTime;
    if (typeof dateInput === 'string') {
        dt = DateTime.fromISO(dateInput, { zone: 'utc' });
    } else if (dateInput instanceof Date) {
        dt = DateTime.fromJSDate(dateInput);
    } else {
        return null; 
    }
    
    if (!dt.isValid) return null;

    return Timestamp.fromDate(dt.setZone('Asia/Kolkata').toJSDate());
};

// This function prepares data for Firestore.
// It can accept form data (with string dates) or partial event data (potentially with Timestamps).
// For updates, the input 'data' object should already include 'id' and 'createdAt' (merged by the store).
// For new events, 'createdAt' should be added by the store, and 'id' is typically auto-generated by Firestore.
export const mapEventDataToFirestore = (data: EventFormData | Partial<Event>): any => {
    // Clone the input data to avoid modifying the original object.
    // All properties from 'data' (like 'id', 'createdAt', 'status', 'votingOpen' if provided for an update)
    // will be part of firestoreData.
    const firestoreData: any = { ...data };
    
    // Handle date conversion to Firestore Timestamps for event details
    // data.details.date.start could be string | null (from EventFormData) or Timestamp | null (from Partial<Event>)
    // convertToTimestamp handles both.
    if (data.details?.date?.start || data.details?.date?.end) {
        // Ensure details and date objects exist before assigning
        firestoreData.details = firestoreData.details || {};
        firestoreData.details.date = firestoreData.details.date || {};

        if (data.details.date.start) {
            (firestoreData.details.date as any).start = convertToTimestamp(data.details.date.start);
        }
        
        if (data.details.date.end) {
            (firestoreData.details.date as any).end = convertToTimestamp(data.details.date.end);
        }
    }
    
    // The 'id' and 'createdAt' fields, if present in the input 'data' (especially for updates),
    // are preserved due to the initial spread { ...data }.
    // The Firestore rules require 'id' and 'createdAt' to be present and correct for updates.
    // For new events, 'id' is usually not set by the client, and 'createdAt' is added by the store or rules.

    // Always set/update lastUpdatedAt for both new and existing events.
    firestoreData.lastUpdatedAt = serverTimestamp();
    
    return firestoreData;
};

// Helper function to convert different date formats to Firestore Timestamp
function convertToTimestamp(dateValue: any): Timestamp | null {
    if (!dateValue) return null;
    
    try {
        let dateTime: DateTime;
        
        if (typeof dateValue === 'string') {
            dateTime = DateTime.fromISO(dateValue);
        } else if (dateValue instanceof Date) {
            dateTime = DateTime.fromJSDate(dateValue);
        } else if (dateValue && typeof dateValue === 'object' && 'toDate' in dateValue) {
            return dateValue; // Already a Firestore Timestamp
        } else if (dateValue && typeof dateValue === 'object' && 'seconds' in dateValue) {
            return new Timestamp(dateValue.seconds, dateValue.nanoseconds || 0);
        } else {
            console.warn('Unknown date format:', dateValue);
            return null;
        }
        
        if (!dateTime.isValid) {
            console.warn('Invalid date:', dateValue, dateTime.invalidReason);
            return null;
        }
        
        return Timestamp.fromDate(dateTime.toJSDate());
    } catch (error) {
        console.error('Error converting date to Timestamp:', error);
        return null;
    }
}

const tsNullToUndefined = (ts: Timestamp | null): Timestamp | undefined => {
    return ts === null ? undefined : ts;
};

export const mapFirestoreToEventData = (id: string, firestoreData: DocumentData | null | undefined): Event | null => {
    if (!firestoreData) return null;

    const event: Partial<Event> = {
        id,
        ...firestoreData,
    };

    // Convert Firestore date objects back to Event format (Timestamp | null)
    if (event.details && typeof event.details === 'object' && event.details.date && typeof event.details.date === 'object') {
        const sourceStartDate = firestoreData.details?.date?.start;
        if (sourceStartDate instanceof Timestamp) {
            event.details.date.start = sourceStartDate;
        } else if (sourceStartDate) {
            event.details.date.start = getISTTimestamp(sourceStartDate);
        } else {
            event.details.date.start = null;
        }

        const sourceEndDate = firestoreData.details?.date?.end;
        if (sourceEndDate instanceof Timestamp) {
            event.details.date.end = sourceEndDate;
        } else if (sourceEndDate) {
            event.details.date.end = getISTTimestamp(sourceEndDate);
        } else {
            event.details.date.end = null;
        }
    }
    
    // For fields on Event type that are Timestamp | undefined
    const timestampFields: (keyof Event)[] = ['createdAt', 'lastUpdatedAt']; // Removed 'closedAt'
    timestampFields.forEach(field => {
        const fieldValue = firestoreData[field];
        if (fieldValue instanceof Timestamp) {
            (event as any)[field] = fieldValue;
        } else if (fieldValue) {
            (event as any)[field] = tsNullToUndefined(getISTTimestamp(fieldValue));
        } else {
            (event as any)[field] = undefined;
        }
    });

    if (firestoreData.lifecycleTimestamps && typeof firestoreData.lifecycleTimestamps === 'object') {
        event.lifecycleTimestamps = {};
        const lifecycleKeys: (keyof EventLifecycleTimestamps)[] = ['approvedAt', 'startedAt', 'rejectedAt', 'completedAt', 'cancelledAt', 'closedAt'];
        lifecycleKeys.forEach(key => {
            const tsValue = firestoreData.lifecycleTimestamps[key];
            if (tsValue instanceof Timestamp) {
                event.lifecycleTimestamps![key] = tsValue;
            } else if (tsValue) {
                event.lifecycleTimestamps![key] = tsNullToUndefined(getISTTimestamp(tsValue));
            } else {
                event.lifecycleTimestamps![key] = undefined;
            }
        });
    } else if ('lifecycleTimestamps' in event) {
        event.lifecycleTimestamps = undefined;
    }
    
    if (Array.isArray(firestoreData.organizerRatings)) {
        event.organizerRatings = firestoreData.organizerRatings.map((rating: any) => {
            const ratedAtValue = rating.ratedAt;
            return {
                ...rating,
                ratedAt: ratedAtValue instanceof Timestamp ? ratedAtValue : tsNullToUndefined(getISTTimestamp(ratedAtValue)),
            };
        });
    } else if ('organizerRatings' in event) {
         event.organizerRatings = undefined;
    }

    if (Array.isArray(firestoreData.submissions)) {
        event.submissions = firestoreData.submissions.map((sub: any) => {
            const submittedAtValue = sub.submittedAt;
            return {
                ...sub,
                submittedAt: submittedAtValue instanceof Timestamp ? submittedAtValue : tsNullToUndefined(getISTTimestamp(submittedAtValue)),
            };
        });
    } else if ('submissions' in event) {
        event.submissions = undefined;
    }

    if (firestoreData.criteria && typeof firestoreData.criteria === 'object' && !Array.isArray(firestoreData.criteria)) {
        event.criteria = Object.values(firestoreData.criteria) as EventCriteria[];
    } else if (Array.isArray(firestoreData.criteria)) {
        event.criteria = firestoreData.criteria as EventCriteria[];
    } else {
        event.criteria = undefined;
    }

    return event as Event;
};